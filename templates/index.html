{% extends "base.html" %}

{% block title %}PDF Wisdom Chat{% endblock %}

{% block content %}
<div class="flex flex-col h-full max-w-4xl mx-auto w-full px-4 py-6 md:py-10">
    <!-- Welcome message/screen -->
    <div id="welcome-screen" class="flex flex-col items-center justify-center h-full animate-fade-in">
        <!-- Logo/Icon -->
        <div class="mb-6 bg-gradient-radial from-gray-200 to-gray-100 dark:from-grok-800 dark:to-grok-900 p-10 rounded-full">
            <svg xmlns="http://www.w3.org/2000/svg" class="h-16 w-16 text-primary-400" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round">
                <path d="M4 19.5A2.5 2.5 0 0 1 6.5 17H20"></path>
                <path d="M6.5 2H20v20H6.5A2.5 2.5 0 0 1 4 19.5v-15A2.5 2.5 0 0 1 6.5 2z"></path>
            </svg>
        </div>
        
        <!-- Welcome text -->
        <h1 class="text-3xl font-bold mb-3 text-transparent bg-clip-text bg-gradient-to-r from-primary-400 to-accent-400">
            PDF Wisdom
        </h1>
        
        <p class="text-gray-600 dark:text-gray-400 max-w-md text-center mb-8">
            Ask questions about your PDF knowledge base and get intelligent answers powered by vector search.
        </p>
        
        <!-- Initial question input -->
        <div class="w-full max-w-2xl">
            <div class="relative">
                <input 
                    type="text" 
                    id="welcome-input"
                    class="w-full bg-white dark:bg-grok-800 border border-gray-300 dark:border-grok-700 rounded-xl px-4 py-3 pr-12 text-gray-800 dark:text-white placeholder-gray-500 focus:outline-none focus:ring-2 focus:ring-accent-500/50 focus:border-accent-500 transition-all"
                    placeholder="Ask anything about your documents..."
                    autofocus
                >
                <button 
                    id="welcome-send-button"
                    class="absolute right-3 top-1/2 -translate-y-1/2 text-accent-500 hover:text-accent-600 dark:text-accent-400 dark:hover:text-accent-300 transition-colors"
                >
                    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor" class="w-5 h-5">
                        <path d="M3.478 2.405a.75.75 0 00-.926.94l2.432 7.905H13.5a.75.75 0 010 1.5H4.984l-2.432 7.905a.75.75 0 00.926.94 60.519 60.519 0 0018.445-8.986.75.75 0 000-1.218A60.517 60.517 0 003.478 2.405z" />
                    </svg>
                </button>
            </div>
        </div>
    </div>
    
    <!-- Chat interface -->
    <div id="chat-interface" class="hidden flex flex-col h-full">
        <!-- Messages container with pb to make space for fixed input -->
        <div id="chat-messages" class="flex-1 overflow-y-auto mb-4 space-y-6 pb-20">
            <!-- Messages will be inserted here by JavaScript -->
        </div>
        
        <!-- Fixed input form at the bottom -->
        <div id="input-container" class="fixed bottom-0 left-0 right-0 bg-gray-100 dark:bg-grok-900 border-t border-gray-200 dark:border-grok-800 pt-4 pb-4 px-4 z-10">
            <div class="max-w-4xl mx-auto w-full">
                <div id="question-form" class="relative">
                    <textarea 
                        id="question-input" 
                        class="w-full bg-white dark:bg-grok-800 border border-gray-300 dark:border-grok-700 rounded-xl px-4 py-3 pr-12 text-gray-800 dark:text-white placeholder-gray-500 focus:outline-none focus:ring-2 focus:ring-accent-500/50 focus:border-accent-500 resize-none transition-all"
                        placeholder="Ask a question..."
                        rows="1"
                    ></textarea>
                    <button 
                        id="send-button"
                        type="button" 
                        class="absolute right-3 top-1/2 -translate-y-1/2 text-accent-500 hover:text-accent-600 dark:text-accent-400 dark:hover:text-accent-300 disabled:text-gray-400 dark:disabled:text-gray-600 disabled:cursor-not-allowed transition-colors"
                    >
                        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor" class="w-5 h-5">
                            <path d="M3.478 2.405a.75.75 0 00-.926.94l2.432 7.905H13.5a.75.75 0 010 1.5H4.984l-2.432 7.905a.75.75 0 00.926.94 60.519 60.519 0 0018.445-8.986.75.75 0 000-1.218A60.517 60.517 0 003.478 2.405z" />
                        </svg>
                    </button>
                </div>
            </div>
        </div>
    </div>
</div>
{% endblock %}

{% block scripts %}
<script>
    document.addEventListener('DOMContentLoaded', function() {
        // DOM elements
        const welcomeScreen = document.getElementById('welcome-screen');
        const welcomeInput = document.getElementById('welcome-input');
        const welcomeSendButton = document.getElementById('welcome-send-button');
        const chatInterface = document.getElementById('chat-interface');
        const chatMessages = document.getElementById('chat-messages');
        const questionForm = document.getElementById('question-form');
        const questionInput = document.getElementById('question-input');
        const sendButton = document.getElementById('send-button');
        
        // Auto-resize textarea
        questionInput.addEventListener('input', function() {
            this.style.height = 'auto';
            this.style.height = (this.scrollHeight) + 'px';
            if (this.scrollHeight > 150) {
                this.style.overflowY = 'auto';
            } else {
                this.style.overflowY = 'hidden';
            }
        });
        
        // Enter key handler for question input (while allowing shift+enter for new lines)
        questionInput.addEventListener('keypress', function(e) {
            if (e.key === 'Enter' && !e.shiftKey) {
                e.preventDefault();
                sendMessage();
            }
        });
        
        // Welcome input handling - Enter key press
        welcomeInput.addEventListener('keypress', function(e) {
            if (e.key === 'Enter') {
                e.preventDefault();
                handleWelcomeInput();
            }
        });
        
        // Welcome input handling - Button click
        welcomeSendButton.addEventListener('click', function(e) {
            e.preventDefault();
            handleWelcomeInput();
        });
        
        function handleWelcomeInput() {
            const question = welcomeInput.value.trim();
            if (question) {
                // Switch to chat interface
                welcomeScreen.classList.add('hidden');
                chatInterface.classList.remove('hidden');
                chatInterface.classList.add('animate-fade-in');
                
                // Process the question
                addUserMessage(question);
                processQuestion(question);
                
                // Focus the chat input
                questionInput.value = '';
                questionInput.focus();
            }
        }
        
        // Change form submission to button click
        sendButton.addEventListener('click', function(e) {
            sendMessage();
        });
        
        // Centralized function to send messages
        function sendMessage() {
            const question = questionInput.value.trim();
            
            if (question) {
                addUserMessage(question);
                processQuestion(question);
                
                questionInput.value = '';
                questionInput.style.height = 'auto';
                questionInput.focus();
            }
        }
        
        // Add a user message to the chat
        function addUserMessage(message) {
            const messageContainer = document.createElement('div');
            messageContainer.className = 'flex justify-end mb-4';
            
            const messageDiv = document.createElement('div');
            messageDiv.className = 'max-w-[80%] bg-gray-700 dark:bg-gray-700 text-white px-5 py-3 rounded-2xl rounded-tr-md message-transition mr-4';
            messageDiv.textContent = message;
            
            messageContainer.appendChild(messageDiv);
            chatMessages.appendChild(messageContainer);
            
            // Scroll to bottom
            scrollToBottom();
        }
        
        // Add an assistant message to the chat
        function addAssistantMessage(message) {
            const messageContainer = document.createElement('div');
            messageContainer.className = 'flex justify-start mb-4';
            
            const messageDiv = document.createElement('div');
            messageDiv.className = 'max-w-[100%] bg-gray-200 dark:bg-grok-800 text-gray-800 dark:text-white px-5 py-3 rounded-2xl rounded-tl-md message-transition ml-4';
            
            if (message && message.trim() !== '') {
                messageDiv.textContent = message;
            }
            
            messageContainer.appendChild(messageDiv);
            chatMessages.appendChild(messageContainer);
            
            // Scroll to bottom
            scrollToBottom();
            
            return messageDiv;
        }
        
        // Add typing indicator
        function addTypingIndicator() {
            const messageContainer = document.createElement('div');
            messageContainer.className = 'flex justify-start';
            messageContainer.id = 'typing-indicator';
            
            const typingDiv = document.createElement('div');
            typingDiv.className = 'bg-gray-200 dark:bg-grok-800 px-5 py-4 rounded-2xl rounded-tl-md flex items-center space-x-1';
            
            for (let i = 0; i < 3; i++) {
                const dot = document.createElement('div');
                dot.className = 'typing-dot h-2 w-2 bg-gray-500 dark:bg-gray-400 rounded-full';
                typingDiv.appendChild(dot);
            }
            
            messageContainer.appendChild(typingDiv);
            chatMessages.appendChild(messageContainer);
            
            // Scroll to bottom
            scrollToBottom();
        }
        
        // Remove typing indicator
        function removeTypingIndicator() {
            const indicator = document.getElementById('typing-indicator');
            if (indicator) {
                indicator.remove();
            }
        }
        
        // Enhanced scroll to bottom function with continuous scrolling behavior
        function scrollToBottom() {
            // Force immediate scroll
            setTimeout(() => {
                chatMessages.scrollTop = chatMessages.scrollHeight;
                // Also ensure the whole page is scrolled to the bottom
                window.scrollTo(0, document.body.scrollHeight);
            }, 0);
            
            // Global observer reference so we can disconnect it properly
            if (window.currentScrollObserver) {
                window.currentScrollObserver.disconnect();
            }
            
            // Create a new MutationObserver
            const observer = new MutationObserver((mutations) => {
                // Force scroll in next event loop
                setTimeout(() => {
                    chatMessages.scrollTop = chatMessages.scrollHeight;
                    // Also ensure the whole page is scrolled to the bottom
                    window.scrollTo(0, document.body.scrollHeight);
                }, 0);
            });
            
            // Store observer reference globally
            window.currentScrollObserver = observer;
            
            // Start observing the chat messages container with all possible options
            observer.observe(chatMessages, { 
                childList: true,
                subtree: true,
                characterData: true,
                attributes: true 
            });
            
            // Set up multiple scroll attempts with increasing delays
            for (let i = 1; i <= 10; i++) {
                setTimeout(() => {
                    chatMessages.scrollTop = chatMessages.scrollHeight;
                    window.scrollTo(0, document.body.scrollHeight);
                }, i * 100); // 100ms, 200ms, 300ms, etc. up to 1000ms
            }
            
            // Long-running scroll monitoring for streaming responses
            let scrollMonitorCount = 0;
            const scrollMonitor = setInterval(() => {
                // Use RAF to ensure smooth scrolling
                requestAnimationFrame(() => {
                    chatMessages.scrollTop = chatMessages.scrollHeight;
                    window.scrollTo(0, document.body.scrollHeight);
                });
                
                scrollMonitorCount++;
                
                // Stop after 20 seconds (200 * 100ms = 20s)
                if (scrollMonitorCount > 200) {
                    clearInterval(scrollMonitor);
                }
            }, 100);
            
            // Store the interval ID so we can clear it when needed
            if (window.currentScrollMonitor) {
                clearInterval(window.currentScrollMonitor);
            }
            window.currentScrollMonitor = scrollMonitor;
        }
        
        // Function to stop all active scrolling
        function stopScrolling() {
            if (window.currentScrollObserver) {
                window.currentScrollObserver.disconnect();
                window.currentScrollObserver = null;
            }
            
            if (window.currentScrollMonitor) {
                clearInterval(window.currentScrollMonitor);
                window.currentScrollMonitor = null;
            }
        }
        
        // Create a progress container in an assistant message
        function createProgressContainer() {
            const messageContainer = document.createElement('div');
            messageContainer.className = 'flex justify-start mb-4';
            
            const messageDiv = document.createElement('div');
            messageDiv.className = 'max-w-[94%] text-gray-800 dark:text-white px-5 py-3 rounded-2xl message-transition ml-4';
            
            const progressId = `progress-${Date.now()}`;
            const progressContainer = document.createElement('div');
            progressContainer.id = progressId;
            progressContainer.className = 'pb-2';
            
            messageDiv.appendChild(progressContainer);
            messageContainer.appendChild(messageDiv);
            chatMessages.appendChild(messageContainer);
            
            // Scroll to bottom
            scrollToBottom();
            
            return {
                containerId: progressId, 
                messageElement: messageDiv
            };
        }
        
        // Update progress with steps visualization
        function updateProgressVisualization(containerId, steps) {
            const container = document.getElementById(containerId);
            if (!container) return null;
            
            container.innerHTML = '';
            
            // Only add the progress steps we want to show
            const stepsToShow = steps.filter(step => step.id !== 'answer');
            
            const stepsContainer = document.createElement('div');
            stepsContainer.className = 'py-2 px-3 space-y-2 text-sm text-gray-500 dark:text-gray-400';
            
            stepsToShow.forEach(step => {
                const stepElement = document.createElement('div');
                stepElement.dataset.stepId = step.id;
                
                // Determine status classes
                let statusClasses = 'text-gray-400 dark:text-gray-500';
                let statusIcon = '◦'; // default - not started
                
                if (step.status === 'processing') {
                    statusClasses = 'text-accent-500 dark:text-accent-400';
                    statusIcon = '◯'; // processing
                } else if (step.status === 'completed') {
                    statusClasses = 'text-primary-500 dark:text-primary-400';
                    statusIcon = '●'; // completed
                }
                
                stepElement.className = `flex items-center space-x-2 ${statusClasses} transition-colors duration-300`;
                
                const icon = document.createElement('span');
                icon.textContent = statusIcon;
                icon.className = step.status === 'processing' ? 'animate-pulse-slow' : '';
                icon.style.width = '16px'; // Fixed width for consistent alignment
                icon.style.textAlign = 'center';
                
                const text = document.createElement('span');
                text.textContent = step.name;
                
                stepElement.appendChild(icon);
                stepElement.appendChild(text);
                stepsContainer.appendChild(stepElement);
            });
            
            container.appendChild(stepsContainer);
            scrollToBottom();
            
            return container;
        }
        
        // Add streamed text to a message element
        function appendStreamedText(messageElement, text) {
            // Create or get the answer content element
            let answerElement = messageElement.querySelector('.answer-content');
            
            if (!answerElement) {
                answerElement = document.createElement('div');
                answerElement.className = 'answer-content whitespace-pre-line';
                messageElement.appendChild(answerElement);
            }
            
            // Append the new text
            answerElement.textContent += text;
            scrollToBottom();
        }
        
        // Process the user question
        async function processQuestion(question) {
            // Disable input during processing
            sendButton.disabled = true;
            questionInput.disabled = true;
            
            // Add assistant's typing indicator
            addTypingIndicator();
            
            try {
                // Send question to API
                const response = await fetch('/api/ask', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({ question })
                });
                
                const data = await response.json();
                
                if (data.error) {
                    removeTypingIndicator();
                    addAssistantMessage(`Sorry, I encountered an error: ${data.error}`);
                    return;
                }
                
                if (data.status === 'processing' && data.session_id) {
                    // Remove typing indicator
                    removeTypingIndicator();
                    
                    // Create message element for answer
                    const progress = createProgressContainer();
                    
                    // Initialize steps (only show analyzing and searching)
                    const steps = [
                        { id: 'decompose', name: 'Analyzing question', status: 'waiting' },
                        { id: 'search', name: 'Searching knowledge base', status: 'waiting' },
                        { id: 'answer', name: 'Generating answer', status: 'waiting' } // Still track this but don't display
                    ];
                    
                    // Display initial progress
                    updateProgressVisualization(progress.containerId, steps);
                    
                    // Connect to event stream for real-time updates
                    connectToEventStream(data.session_id, progress);
                } else {
                    // Fallback for older API format
                    removeTypingIndicator();
                    if (data.answer) {
                        addAssistantMessage(data.answer);
                    } else {
                        addAssistantMessage('Sorry, something went wrong. Please try again.');
                    }
                }
            } catch (error) {
                console.error('Error:', error);
                removeTypingIndicator();
                addAssistantMessage('Sorry, something went wrong. Please try again later.');
            } finally {
                // Re-enable input
                sendButton.disabled = false;
                questionInput.disabled = false;
                // Focus back on input for convenience
                questionInput.focus();
            }
        }
        
        // Connect to Server-Sent Events stream
        function connectToEventStream(sessionId, progress) {
            const eventSource = new EventSource(`/api/progress-stream/${sessionId}`);
            
            // Track steps
            const steps = [
                { id: 'decompose', name: 'Analyzing question', status: 'waiting' },
                { id: 'search', name: 'Searching knowledge base', status: 'waiting' },
                { id: 'answer', name: 'Generating answer', status: 'waiting' }
            ];
            
            // Variables for streaming answer
            let lastAnswerChunk = '';
            let isAnswerStreaming = false;
            let answerMessageElement = null;
            let answerContent = '';
            
            // Start continuous scrolling for the duration of the stream
            scrollToBottom();
            
            eventSource.onmessage = function(event) {
                console.log('Event received:', event.data); // Debug logging
                
                try {
                    const data = JSON.parse(event.data);
                    
                    if (data.event === 'step_update') {
                        // Update step status
                        const stepIndex = steps.findIndex(s => s.id === data.step_id);
                        if (stepIndex !== -1) {
                            steps[stepIndex].status = data.status;
                            
                            // Update previous steps if needed
                            if (data.status === 'processing' || data.status === 'completed') {
                                for (let i = 0; i < stepIndex; i++) {
                                    if (steps[i].status !== 'completed') {
                                        steps[i].status = 'completed';
                                    }
                                }
                            }
                            
                            // Update visualization (but don't show the answer step)
                            updateProgressVisualization(progress.containerId, steps);
                            
                            // For all events, ensure we're scrolled to the bottom
                            scrollToBottom();
                            
                            // If answer generation starts, prepare for streaming by creating a new message bubble
                            // IMPORTANT: Create the answer message bubble immediately after its progress container
                            if (data.step_id === 'answer' && data.status === 'processing') {
                                isAnswerStreaming = true;
                                
                                // Find the progress container element
                                const progressContainer = document.getElementById(progress.containerId);
                                
                                // Create a new message bubble for the answer that will appear after the progress container
                                answerMessageElement = document.createElement('div');
                                answerMessageElement.className = 'max-w-[100%] text-gray-800 dark:text-white rounded-2xl rounded-tl-md message-transition ml-4';
                                
                                // Insert the answer element after the progress container's parent (the message div)
                                if (progressContainer && progressContainer.parentElement) {
                                    progressContainer.parentElement.appendChild(answerMessageElement);
                                } else {
                                    // Fallback if we can't find the progress container
                                    answerMessageElement = addAssistantMessage('');
                                }
                                
                                // Scroll to bottom to show the new message element
                                scrollToBottom();
                            }
                        }
                    }
                    else if (data.event === 'answer_chunk') {
                        // Handle streaming answer chunks in the dedicated answer bubble
                        if (data.text && data.text !== lastAnswerChunk) {
                            if (!answerMessageElement) {
                                // Fallback - Create a message bubble for the answer if it doesn't exist
                                answerMessageElement = addAssistantMessage('');
                            }
                            // Append text to answer content
                            answerContent += data.text;
                            // Update the message bubble with the accumulated content
                            answerMessageElement.textContent = answerContent;
                            lastAnswerChunk = data.text;
                            // Scroll to bottom to show the updated message
                            scrollToBottom();
                        }
                    }
                    else if (data.event === 'result') {
                        // Process is complete
                        let answer = '';
                        if (data.answer) {
                            answer = data.answer;
                        } else if (data.data && data.data.answer) {
                            answer = data.data.answer;
                        }
                        
                        // Only add the answer if we haven't been streaming it already
                        if (answer && !isAnswerStreaming) {
                            // Find the progress container element
                            const progressContainer = document.getElementById(progress.containerId);
                            
                            // Create a new message bubble that will appear after the progress container
                            answerMessageElement = document.createElement('div');
                            answerMessageElement.className = 'max-w-[100%] bg-gray-200 dark:bg-grok-800 text-gray-800 dark:text-white px-5 py-3 rounded-2xl rounded-tl-md message-transition ml-4';
                            answerMessageElement.textContent = answer;
                            
                            // Insert the answer element after the progress container's parent (the message div)
                            if (progressContainer && progressContainer.parentElement) {
                                progressContainer.parentElement.appendChild(answerMessageElement);
                            } else {
                                // Fallback if we can't find the progress container
                                answerMessageElement = addAssistantMessage(answer);
                            }
                        } else if (isAnswerStreaming && answerMessageElement && !answerContent) {
                            // If streaming was started but no content was received, show the answer
                            answerMessageElement.textContent = answer;
                        }
                        
                        // Make sure all steps are marked as completed
                        steps.forEach(step => step.status = 'completed');
                        updateProgressVisualization(progress.containerId, steps);
                        
                        // Close the event stream
                        eventSource.close();
                        
                        // Final scroll to bottom
                        scrollToBottom();
                        
                        // Stop continuous scrolling after a delay
                        setTimeout(() => {
                            stopScrolling();
                        }, 1000);
                        
                        // Re-focus on input field
                        questionInput.focus();
                    }
                    else if (data.event === 'complete' || data.event === 'end') {
                        // Close the event stream on completion
                        eventSource.close();
                        
                        // Final scroll to bottom
                        scrollToBottom();
                        
                        // Stop continuous scrolling after a delay
                        setTimeout(() => {
                            stopScrolling();
                        }, 1000);
                        
                        // Re-focus on input field
                        questionInput.focus();
                    }
                } catch (error) {
                    console.error('Error processing event:', error);
                    // If we don't have an answer bubble yet, create one for the error
                    if (!answerMessageElement) {
                        addAssistantMessage('Error processing response');
                    }
                    eventSource.close();
                    stopScrolling();
                }
            };
            
            eventSource.onerror = function(error) {
                // Handle event stream errors
                console.error('EventSource error:', error);
                eventSource.close();
                // If we don't have an answer bubble yet, create one for the error
                if (!answerMessageElement) {
                    addAssistantMessage('Sorry, I lost connection. Please try again.');
                }
                stopScrolling();
            };
        }
    });
</script>
{% endblock %}